package cn.spdb.harrier.common.utils;import java.text.ParseException;import java.text.SimpleDateFormat;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.util.Calendar;import java.util.Date;import org.apache.commons.lang3.ObjectUtils;import org.quartz.CronExpression;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * date utils */public class DateUtils {	private static final Logger logger = LoggerFactory.getLogger(DateUtils.class);	// ------------------时间单位-----------------	public static final int TIME_MILLSECOND_OF_SECOND = 1000;	public static final int TIME_MILLSECOND_OF_MINUTE = 60 * TIME_MILLSECOND_OF_SECOND;	public static final int TIME_MILLSECOND_OF_HORE = 60 * TIME_MILLSECOND_OF_MINUTE;	public static final int TIME_MILLSECOND_OF_DAY = 24 * TIME_MILLSECOND_OF_HORE;	// ------------------时间格式-------------------	public static final String PATTERN_HHMMSS = "HH:mm:ss";	public static final String PATTERN_HHMMSS_CONS = "HHmmss";	public static final String PATTERN_YYYYMMDD = "yyyy-MM-dd";	public static final String PATTERN_YYYYMMDD_CONS = "yyyyMMdd";	public static final String PATTERN_NORMAL = "yyyy-MM-dd HH:mm:ss";	public static final String PATTERN_NORMAL_CONS = "yyyyMMddHHmmss";	/**	 * date to local datetime	 *	 * @param date date	 * @return local datetime	 */	public static LocalDateTime date2LocalDateTime(Date date) {		return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());	}	/**	 * local datetime to date	 *	 * @param localDateTime local datetime	 * @return date	 */	public static Date localDateTime2Date(LocalDateTime localDateTime) {		Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant();		return Date.from(instant);	}		/**	 * get current date str	 *	 * @return date string	 */	public static String getCurrentTime() {		return getCurrentTime(DateUtils.PATTERN_NORMAL);	}	/**	 * get the date string in the specified format of the current time	 *	 * @param format date format	 * @return date string	 */	public static String getCurrentTime(String format) {		return LocalDateTime.now().format(DateTimeFormatter.ofPattern(format));	}	/**	 * get the formatted date string	 *	 * @param date   date	 * @param format e.g. yyyy-MM-dd HH:mm:ss	 * @return date string	 */	public static String format(Date date, String format) {		return format(date2LocalDateTime(date), format);	}	/**	 * get the formatted date string	 *	 * @param localDateTime local data time	 * @param format        yyyy-MM-dd HH:mm:ss	 * @return date string	 */	public static String format(LocalDateTime localDateTime, String format) {		return localDateTime.format(DateTimeFormatter.ofPattern(format));	}	/**	 * convert time to yyyy-MM-dd HH:mm:ss format	 *	 * @param date date	 * @return date string	 */	public static String dateToString(Date date) {		return format(date, DateUtils.PATTERN_NORMAL);	}	/**	 * convert string to date and time	 *	 * @param date   date	 * @param format format	 * @return date	 */	public static Date parse(String date, String format) {		try {			LocalDateTime ldt = LocalDateTime.parse(date, DateTimeFormatter.ofPattern(format));			return localDateTime2Date(ldt);		} catch (Exception e) {			logger.error("error while parse date:" + date, e);		}		return null;	}	/**	 * convert date str to yyyy-MM-dd HH:mm:ss format	 *	 * @param str date string	 * @return yyyy-MM-dd HH:mm:ss format	 */	public static Date stringToDate(String str) {		return parse(str, DateUtils.PATTERN_NORMAL);	}	/**	 * get seconds between two dates	 *	 * @param d1 date1	 * @param d2 date2	 * @return differ seconds	 */	public static long differSec(Date d1, Date d2) {		if (d1 == null || d2 == null) {			return 0;		}		return (long) Math.ceil(differMs(d1, d2) / 1000.0);	}	/**	 * get ms between two dates	 *	 * @param d1 date1	 * @param d2 date2	 * @return differ ms	 */	public static long differMs(Date d1, Date d2) {		return Math.abs(d1.getTime() - d2.getTime());	}	/**	 * get hours between two dates	 *	 * @param d1 date1	 * @param d2 date2	 * @return differ hours	 */	public static long diffHours(Date d1, Date d2) {		return (long) Math.ceil(diffMin(d1, d2) / 60.0);	}	/**	 * get minutes between two dates	 *	 * @param d1 date1	 * @param d2 date2	 * @return differ minutes	 */	public static long diffMin(Date d1, Date d2) {		return (long) Math.ceil(differSec(d1, d2) / 60.0);	}	/**	 * get the date of the specified date in the days before and after	 *	 * @param date date	 * @param day  day	 * @return the date of the specified date in the days before and after	 */	public static Date getSomeDay(Date date, int day) {		Calendar calendar = Calendar.getInstance();		calendar.setTime(date);		calendar.add(Calendar.DATE, day);		return calendar.getTime();	}	/**	 * compare two dates	 *	 * @param future future date	 * @param old    old date	 * @return true if future time greater than old time	 */	public static boolean compare(Date future, Date old) {		return future.getTime() > old.getTime();	}	/**	 * convert schedule string to date	 *	 * @param schedule schedule	 * @return convert schedule string to date	 */	public static Date getScheduleDate(String schedule) {		return stringToDate(schedule);	}	/**	 * format time to readable	 *	 * @param ms ms	 * @return format time	 */	public static String format2Readable(long ms) {		long days = ms / (1000 * 60 * 60 * 24);		long hours = (ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60);		long minutes = (ms % (1000 * 60 * 60)) / (1000 * 60);		long seconds = (ms % (1000 * 60)) / 1000;		return String.format("%02d %02d:%02d:%02d", days, hours, minutes, seconds);	}	/**	 * get monday	 *	 * note: Set the first day of the week to Monday, the default is Sunday	 * 	 * @param date date	 * @return get monday	 */	public static Date getMonday(Date date) {		Calendar cal = Calendar.getInstance();		cal.setTime(date);		cal.setFirstDayOfWeek(Calendar.MONDAY);		cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);		return cal.getTime();	}	/**	 * get sunday	 *	 * note: Set the first day of the week to Monday, the default is Sunday	 * 	 * @param date date	 * @return get sunday	 */	public static Date getSunday(Date date) {		Calendar cal = Calendar.getInstance();		cal.setTime(date);		cal.setFirstDayOfWeek(Calendar.MONDAY);		cal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);		return cal.getTime();	}	/**	 * get first day of month	 *	 * @param date date	 * @return first day of month	 */	public static Date getFirstDayOfMonth(Date date) {		Calendar cal = Calendar.getInstance();		cal.setTime(date);		cal.set(Calendar.DAY_OF_MONTH, 1);		return cal.getTime();	}	/**	 * get some hour of day	 *	 * @param date       date	 * @param offsetHour hours	 * @return some hour of day	 */	public static Date getSomeHourOfDay(Date date, int offsetHour) {		Calendar cal = Calendar.getInstance();		cal.setTime(date);		cal.set(Calendar.HOUR_OF_DAY, cal.get(Calendar.HOUR_OF_DAY) + offsetHour);		cal.set(Calendar.MINUTE, 0);		cal.set(Calendar.SECOND, 0);		cal.set(Calendar.MILLISECOND, 0);		return cal.getTime();	}	/**	 * get last day of month	 *	 * @param date date	 * @return get last day of month	 */	public static Date getLastDayOfMonth(Date date) {		Calendar cal = Calendar.getInstance();		cal.setTime(date);		cal.add(Calendar.MONTH, 1);		cal.set(Calendar.DAY_OF_MONTH, 1);		cal.add(Calendar.DAY_OF_MONTH, -1);		return cal.getTime();	}	/**	 * return YYYY-MM-DD 00:00:00	 *	 * @param inputDay date	 * @return start day	 */	public static Date getStartOfDay(Date inputDay) {		Calendar cal = Calendar.getInstance();		cal.setTime(inputDay);		cal.set(Calendar.HOUR_OF_DAY, 0);		cal.set(Calendar.MINUTE, 0);		cal.set(Calendar.SECOND, 0);		cal.set(Calendar.MILLISECOND, 0);		return cal.getTime();	}	/**	 * return YYYY-MM-DD 23:59:59	 *	 * @param inputDay day	 * @return end of day	 */	public static Date getEndOfDay(Date inputDay) {		Calendar cal = Calendar.getInstance();		cal.setTime(inputDay);		cal.set(Calendar.HOUR_OF_DAY, 23);		cal.set(Calendar.MINUTE, 59);		cal.set(Calendar.SECOND, 59);		cal.set(Calendar.MILLISECOND, 999);		return cal.getTime();	}	/**	 * return YYYY-MM-DD 00:00:00	 *	 * @param inputDay day	 * @return start of hour	 */	public static Date getStartOfHour(Date inputDay) {		Calendar cal = Calendar.getInstance();		cal.setTime(inputDay);		cal.set(Calendar.MINUTE, 0);		cal.set(Calendar.SECOND, 0);		cal.set(Calendar.MILLISECOND, 0);		return cal.getTime();	}	/**	 * return YYYY-MM-DD 23:59:59	 *	 * @param inputDay day	 * @return end of hour	 */	public static Date getEndOfHour(Date inputDay) {		Calendar cal = Calendar.getInstance();		cal.setTime(inputDay);		cal.set(Calendar.MINUTE, 59);		cal.set(Calendar.SECOND, 59);		cal.set(Calendar.MILLISECOND, 999);		return cal.getTime();	}	/**	 * get current date	 * 	 * @return current date	 */	public static Date getCurrentDate() {		return DateUtils.parse(DateUtils.getCurrentTime(), DateUtils.PATTERN_NORMAL);	}	/**	 * get date	 * 	 * @param date          date	 * @param calendarField calendarField	 * @param amount        amount	 * @return date	 */	public static Date add(final Date date, final int calendarField, final int amount) {		if (date == null) {			throw new IllegalArgumentException("The date must not be null");		}		final Calendar c = Calendar.getInstance();		c.setTime(date);		c.add(calendarField, amount);		return c.getTime();	}	public static int get(int field) {		Calendar calendar = Calendar.getInstance();		return calendar.get(field);	}	public static boolean isTimeWindowRang(String timeWinds) {		if (!timeWinds.matches("[0-9]+:[0-9]+\\-[0-9]+:[0-9]+")) {			return false;		}		String[] times = timeWinds.split(Symbol.HENG_GANG);		String[] startStr = times[0].split(Symbol.MAO_HAO);		String[] endStr = times[1].split(Symbol.MAO_HAO);		int startHour = Integer.parseInt(startStr[0].trim());		int startMinute = Integer.parseInt(startStr[1].trim());		int endHour = Integer.parseInt(endStr[0].trim());		int endMinute = Integer.parseInt(endStr[1].trim());		int hour = DateUtils.get(Calendar.HOUR_OF_DAY);		int minute = DateUtils.get(Calendar.MINUTE);		int start = startHour * 100 + startMinute;		int end = endHour * 100 + endMinute;		int now = hour * 100 + minute;		if (start > 2400 || end > 2400 || start < 0 || end < 0 || start == end) {			return false;		}		if (start < end) {			if (start < now && now < end) {				return true;			}		} else {			if ((0 < now && now < end) || (start < now && now < 2400)) {				return true;			}		}		return false;	}	public static LocalDateTime getNextValidTime(String cron, LocalDateTime localDateTime) throws ParseException {		Date date = getNextValidTime(cron, localDateTime2Date(localDateTime));		return date2LocalDateTime(date);	}	public static Date getNextValidTime(String cron, Date date) throws ParseException {		cron = cron.trim();		CronExpression tmpCronExpression = new CronExpression(cron);		Date tmpDate = tmpCronExpression.getNextValidTimeAfter(date);		return tmpDate;	}	public static Boolean isSatisfiedBy(String cron, Date date)  {		try {			CronExpression tmpCronExpression = new CronExpression(cron);			return tmpCronExpression.isSatisfiedBy(date);		} catch (ParseException e) {			e.printStackTrace();		}		return false;	}	public static Date getNextValidTime(String[] crons, Date date) {		Date nextMinDate = null;		for (String cron : crons) {			try {				Date nextDate = getNextValidTime(cron, date);				if (ObjectUtils.isEmpty(nextMinDate) || nextMinDate.compareTo(nextDate) > 0) {					nextMinDate = nextDate;				}			} catch (ParseException e) {				e.printStackTrace();			}		}		return nextMinDate;	}	public static LocalDate getNextValidTime(String[] crons, LocalDate localDate) {		if (ObjectUtils.isEmpty(localDate)) {			return null;		}		Date nextMinDate = getNextValidTime(crons, localDateTime2Date(localDate.atStartOfDay()));		if (ObjectUtils.isEmpty(nextMinDate)) {			return null;		}		return date2LocalDateTime(nextMinDate).toLocalDate();	}	public static boolean isDate(String strDate, String pattern) {		SimpleDateFormat dateFormat = new SimpleDateFormat(pattern);		dateFormat.setLenient(false);		try {			dateFormat.parse(strDate);			return true;		} catch (ParseException e) {			e.printStackTrace();			return false;		}	}}